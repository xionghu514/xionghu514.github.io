# 多线程

## 相关概念

* 理想状态下多线程并没有提高效率, 但是 cpu 的使用率不是百分百的, 会有空闲时间(IO 或者 网络时就需要等待). 多线程的本质就是提高资源使用效率来提高系统的效率. 某一个线程执行到 IO 或者网络操作时 另一个线程获取 cpu 执行权, 减少 CPU 等待时间提升性能

  

![image-20221216132754418](https://oss.yiki.tech/xh/image-20221216132754418.png)

* 并行与并发

  * 并行：在同一个时间点上，两个任务同时运行

  * 并发：在一个CPU上，多个任务交替执行

* 进程与线程

  * 进程：一个应用程序中包含多个进程，一个进程就是一个独立的运行任务。
  * 线程：一个运行任务可能体积较大，我们可以将其切割成多个子任务，然后每个子任务使用一个线程去计算，最后再将多个线程计算的结果合并。 一个进程包含多个线程。 **简单来说线程就是进程中不可分割的执行单元**
  * 进程是独立的，进程之间的数据是不共享的。但是，一个进程中的多个线程是共享内存空间的，从而能够完成线程之间的通信。

  ![image-20221216135540882](https://oss.yiki.tech/xh/image-20221216135540882.png)

* 操作系统任务调度的两种模式
  * 分时操作系统：我们认为cpu是计算资源，单cpu情况下，我们将cpu的计算资源进行切割，切割成无数个微小的计算单元。平均分配给多个线程去执行。
  * 抢占式：cpu的计算资源-时间片，不是平均分配的，而是靠抢的，谁的优先级高，那么谁获得cpu时间片的概率就大



## 线程创建方式

* 继承Thread类
  * java是单继承的，扩展性差
  * 没有返回值
  * 不能抛出异常
  * 很难控制线程数
* 实现Runnable接口
  * 没有返回值
  * 不能抛出异常
  * 很难控制线程数



## 线程生命周期

创建  →  就绪  → 运行  →  销毁

​				↑				↓

​			 阻塞(等待，睡眠 )





![image-20221216173015115](https://oss.yiki.tech/xh/image-20221216173015115.png)



| 名称     | 解释                                                         |
| -------- | :----------------------------------------------------------- |
| 普通线程 | 优先级默认是5                                                |
| 守护线程 | setDaemon()为了保证`普通线程`能够正常执行的**一类**线程，不能单独运行，优先级比普通线程低，普通线程结束时，守护线程也要结束。                                                                                                                                                                                         可以通过setDaemon(boolean on) 来设置某线程为守护线程(必须在 start() 调用前调用)<br />用isDaemon() 来判断是否是精灵线程<br /> |

